#!/usr/bin/env python
"""The command interface for the anime_downloader module."""

import os

import click

from anime_downloader import animevost
from anime_downloader import library
from anime_downloader.exceptions import *

PATH_TO_CONFIG_DIR = os.path.expanduser('~/.config/anime-downloader')
try:
    os.mkdir(PATH_TO_CONFIG_DIR)
except FileExistsError:
    pass

PATH_TO_CONFIG = os.path.join(PATH_TO_CONFIG_DIR, 'config')
try:
    CONFIG = library.Config(os.path.expanduser(PATH_TO_CONFIG))
except NotEnoughArgumentsToInitializeError:
    CONFIG = library.Config(
        PATH_TO_CONFIG,
        path_to_db=os.path.join(PATH_TO_CONFIG_DIR, 'db'),
        path_to_downloads=os.popen('xdg-user-dir DOWNLOAD').read().rstrip()
    )


@click.command()
@click.option(
    '-a', '--add',
    is_flag=True,
    help='add a release to the DB'
)
@click.option(
    '-r', '--remove',
    is_flag=True,
    help='remove release from DB'
)
@click.option(
    '-db', '--path-to-db',
    type=str,
    default=CONFIG.path_to_db,
    help='configure the path to the DB'
)
@click.option(
    '-lsdb', '--list-db',
    is_flag=True,
    help='print db'
)
@click.option(
    '-lsrr', '--list-recent-releases',
    is_flag=True,
    help='print a list of recent releases (oldest to most recent)'
)
@click.option(
    '-d', '--download',
    is_flag=True,
    help='download episode(s)'
)
@click.option(
    '-da', '--download-auto',
    is_flag=True,
    help='download the latest episodes of releases that have added episodes'
)
@click.option(
    '-downloads', '--path-to-downloads',
    type=str,
    default=CONFIG.path_to_downloads,
    help='configure the path to downloads'
)
@click.option(
    '--mkdir/--no-mkdir',
    default=None,
    help='enable/disable the flag of creating folders before upload'
)
@click.option(
    '--save',
    is_flag=True,
    help='save settings'
)
def main(
    add: bool,
    remove: bool,
    path_to_db: str,
    list_db: bool,
    list_recent_releases: bool,
    download: bool,
    download_auto: bool,
    path_to_downloads: str,
    mkdir: bool,
    save: bool
):
    path_to_db = os.path.expanduser(path_to_db)
    if save and path_to_db != CONFIG.path_to_db:
        CONFIG.path_to_db = path_to_db
    if save and path_to_downloads != CONFIG.path_to_downloads:
        CONFIG.path_to_downloads = path_to_downloads
    if save:
        CONFIG.save()

    if add:
        search_query = input("Enter your search query: ")
        animevost.Animevost(search_query).save_to_db(path_to_db)
    elif remove:
        library.print_db(path_to_db)

        release_index_for_delete = int(
            input("Enter the release number you want to remove: ")
        ) - 1
        db = library.get_db(path_to_db)
        db[release_index_for_delete].delete_from_db(path_to_db)
    elif download:
        library.print_db(path_to_db)

        release_index = int(
            input("Enter the release number for which you want to download the"
                  + " episode(s): ")
        ) - 1
        release_playlist = library.get_db(path_to_db)[release_index].playlist
        episode = input("Enter the episode(s) you want to download: ")
        try:
            episode = int(episode) if episode else None
            if mkdir is None:
                mkdir = False
            release_playlist.download_episode(episode, path_to_downloads, mkdir)
        except ValueError:
            episode_start, episode_stop = [i for i in episode.split(':')]
            episode_start = int(episode_start) if episode_start else None
            episode_stop = int(episode_stop) if episode_stop else None
            if mkdir is None:
                mkdir = True
            release_playlist.download_episodes(
                episode_start,
                episode_stop,
                path_to_downloads,
                mkdir
            )

    elif download_auto:
        library.update_and_save_all_db(path_to_db)
        try:
            updated_releases = library.get_updated_releases_from_db(path_to_db)
        except NoUpdatedReleasesError:
            print("Nothing to do.")
            import sys
            sys.exit()

        for animevost_instance in updated_releases:
            release = animevost_instance.release
            title = release.title
            print(f"Downloading the episode of the '{title}' release...")
            animevost_instance.playlist.download_episode()
    elif list_db:
        library.print_db(path_to_db)
    elif list_recent_releases:
        recent_releases = animevost.get_recent_releases()
        recent_releases.reverse()
        for release in recent_releases:
            title = release.title
            link = release.link
            print(f"{title} ({link})")


try:
    USER = os.getenv('USER')
    PATH_TO_LOCK_FILE = f'/tmp/anime-downloader.{USER}.lock'
    if os.path.exists(PATH_TO_LOCK_FILE):
        raise AnotherInstanceAlreadyRunError

    open(PATH_TO_LOCK_FILE, 'x').close()
    main()
finally:
    try:
        os.remove(PATH_TO_LOCK_FILE)
    except FileNotFoundError:
        print(f"WARNING: the {PATH_TO_LOCK_FILE} file was deleted during script"
              + " execution, so something might have gone wrong.")
